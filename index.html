<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Valanja Vazhi Maps ğŸ—º</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <style>
    body { margin:0; padding:0; }
    #map { width: 100%; height: 90vh; }
  </style>
</head>
<body class="bg-gray-900 text-white">
  <h1 class="text-2xl font-bold text-center py-3">Valanja Vazhi Maps ğŸŒ</h1>

  <!-- Mode Selector -->
  <div class="flex justify-center gap-2 my-2">
    <select id="mode" class="text-black p-2 rounded">
      <option value="normal">ğŸš— Normal Mode</option>
      <option value="snail">ğŸŒ Snail Mode</option>
      <option value="tractor">ğŸšœ Tractor Mode</option>
      <option value="looping">ğŸŒ€ Looping Mode</option>
    </select>
    <input id="search" type="text" placeholder="Search place..." class="text-black p-2 rounded w-60" />
    <button id="go" class="bg-green-500 px-3 rounded">Go</button>
  </div>

  <div id="map"></div>

  <script>
    mapboxgl.accessToken = 'pk.eyJ1Ijoic2FtdWVsbWRpbGVlcCIsImEiOiJjbWN0Mjd4a2cwMG92MmpxdXo3cDlveTlsIn0.QLTaJV0psYYAr9jpJeZjUw';

    const map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/mapbox/streets-v12',
      center: [76.2673, 9.9312],
      zoom: 13
    });

    map.addControl(new mapboxgl.NavigationControl());

    let userMarker;
    let destMarker;
    const routeLayerId = 'route';

    if (navigator.geolocation) {
      navigator.geolocation.watchPosition(pos => {
        const lng = pos.coords.longitude;
        const lat = pos.coords.latitude;

        if (!userMarker) {
          userMarker = new mapboxgl.Marker({ color: 'blue' }).setLngLat([lng, lat]).addTo(map);
        } else {
          userMarker.setLngLat([lng, lat]);
        }
      }, err => console.error(err), { enableHighAccuracy: true });
    }

    // Convert degrees to radians
    function toRad(deg) {
      return deg * Math.PI / 180;
    }

    // Convert radians to degrees
    function toDeg(rad) {
      return rad * 180 / Math.PI;
    }

    // Compute bounding box (minLng, minLat, maxLng, maxLat) around center for given radius in km
    function getBoundingBox(center, radiusKm) {
      const lat = center[1];
      const lng = center[0];

      const earthRadius = 6371; // km

      // Latitude: 1 deg â‰ˆ 110.574 km
      const latDelta = radiusKm / 110.574;

      // Longitude: 1 deg â‰ˆ 111.320*cos(latitude) km
      const lngDelta = radiusKm / (111.320 * Math.cos(toRad(lat)));

      return [
        lng - lngDelta, // minLng
        lat - latDelta, // minLat
        lng + lngDelta, // maxLng
        lat + latDelta  // maxLat
      ];
    }

    // Search POIs near destination within bounding box
    async function searchNearbyPOIs(center, radiusKm) {
      const bbox = getBoundingBox(center, radiusKm);
      // Mapbox Geocoding API allows bbox param to limit search area
      // We search for generic POIs by querying 'poi' (can be customized)
      const query = 'poi';

      const url = https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(query)}.json +
        ?bbox=${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]} +
        &access_token=${mapboxgl.accessToken} +
        &limit=10;

      const res = await fetch(url);
      const data = await res.json();

      // Filter out POIs that are too close to destination (less than 200m) to avoid trivial
      const filtered = data.features.filter(f => {
        const d = distanceBetween(center, f.geometry.coordinates);
        return d > 0.2; // km
      });

      return filtered;
    }

    // Calculate approximate distance between two coords (lng, lat) in km (Haversine formula)
    function distanceBetween(coord1, coord2) {
      const R = 6371; // Earth radius km
      const dLat = toRad(coord2[1] - coord1[1]);
      const dLng = toRad(coord2[0] - coord1[0]);
      const lat1 = toRad(coord1[1]);
      const lat2 = toRad(coord2[1]);

      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.sin(dLng/2) * Math.sin(dLng/2) * Math.cos(lat1) * Math.cos(lat2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    document.getElementById('go').addEventListener('click', async () => {
      const place = document.getElementById('search').value.trim();
      const mode = document.getElementById('mode').value;

      if (!place) return alert('Type a place name!');

      try {
        // Geocode destination
        const geoRes = await fetch(https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(place)}.json?access_token=${mapboxgl.accessToken});
        const geoData = await geoRes.json();

        if (!geoData.features.length) return alert('Place not found');

        const dest = geoData.features[0].geometry.coordinates;

        // Place or move red destination marker
        if (!destMarker) {
          destMarker = new mapboxgl.Marker({ color: 'red' }).setLngLat(dest).addTo(map);
        } else {
          destMarker.setLngLat(dest);
        }

        // Start coords from user or default Kochi
        const start = userMarker ? userMarker.getLngLat().toArray() : [76.2673, 9.9312];

        // Decide radius (km) based on mode
        let radiusKm = 5;
        if (mode === 'snail') radiusKm = 30;
        else if (mode === 'tractor') radiusKm = 15;
        else if (mode === 'looping') radiusKm = 10;

        // Search for nearby POIs around destination
        const pois = await searchNearbyPOIs(dest, radiusKm);

        // Pick one POI randomly as intermediate waypoint (or none if empty)
        let waypoint = null;
        if (pois.length > 0) {
          waypoint = pois[Math.floor(Math.random() * pois.length)].geometry.coordinates;
          console.log('Picked waypoint:', waypoint);
        } else {
          console.log('No nearby POIs found in radius', radiusKm, 'km');
        }

        // Route profile for directions
        let profile = 'driving';
        if (mode === 'snail') profile = 'walking';

        // Build directions URL with waypoint if exists
        // Format: start;waypoint;destination
        let coordsString = ${start[0]},${start[1]};
        if (waypoint) coordsString += ;${waypoint[0]},${waypoint[1]};
        coordsString += ;${dest[0]},${dest[1]};

        const directionsUrl = https://api.mapbox.com/directions/v5/mapbox/${profile}/${coordsString}?geometries=geojson&access_token=${mapboxgl.accessToken};

        const dirRes = await fetch(directionsUrl);
        const dirData = await dirRes.json();

        if (!dirData.routes || dirData.routes.length === 0) return alert('No route found');

        const route = dirData.routes[0].geometry;

        if (!route || !route.coordinates || route.coordinates.length === 0) {
          return alert('Route geometry invalid or empty');
        }

        // Remove old route
        if (map.getLayer(routeLayerId)) {
          map.removeLayer(routeLayerId);
          map.removeSource(routeLayerId);
        }

        // Paint styles for mode
        let paint = {
          'line-color': '#ff0000',
          'line-width': 4,
          'line-opacity': 1
        };
        if (mode === 'snail') {
          paint['line-color'] = '#00ff00';
          paint['line-dasharray'] = [2, 4];
          paint['line-width'] = 3;
        } else if (mode === 'tractor') {
          paint['line-color'] = '#ffa500';
          paint['line-width'] = 6;
        } else if (mode === 'looping') {
          paint['line-color'] = '#00ffff';
          paint['line-width'] = 4;
          paint['line-opacity'] = 0.7;
        }

        map.addSource(routeLayerId, {
          type: 'geojson',
          data: {
            type: 'Feature',
            geometry: route
          }
        });

        map.addLayer({
          id: routeLayerId,
          type: 'line',
          source: routeLayerId,
          layout: { 'line-join': 'round', 'line-cap': 'round' },
          paint: paint
        });

        // Fit map to route bounds
        const bounds = new mapboxgl.LngLatBounds();
        route.coordinates.forEach(c => bounds.extend(c));
        map.fitBounds(bounds, { padding: 50 });

        // Optional: add a marker for intermediate waypoint
        if (waypoint) {
          if (window.waypointMarker) {
            window.waypointMarker.setLngLat(waypoint);
          } else {
            window.waypointMarker = new mapboxgl.Marker({ color: 'yellow' }).setLngLat(waypoint).addTo(map);
          }
        } else if (window.waypointMarker) {
          window.waypointMarker.remove();
          window.waypointMarker = null;
        }

      } catch (error) {
        console.error('Error getting route:', error);
        alert('Error getting route: ' + error.message);
      }
    });
  </script>
</body>
</html>
