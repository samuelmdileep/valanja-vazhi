<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Valanja Vazhi Maps ğŸ—ºï¸</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <style>
    body { margin:0; padding:0; }
    #map { width: 100%; height: 90vh; }
  </style>
</head>
<body class="bg-gray-900 text-white">
  <h1 class="text-2xl font-bold text-center py-3">Valanja Vazhi Maps ğŸŒ</h1>

  <!-- Mode Selector -->
  <div class="flex justify-center gap-2 my-2">
    <select id="mode" class="text-black p-2 rounded">
      <option value="normal">ğŸš— Normal Mode</option>
      <option value="snail">ğŸŒ Snail Mode</option>
      <option value="tractor">ğŸšœ Tractor Mode</option>
      <option value="looping">ğŸŒ€ Looping Mode</option>
    </select>
    <input id="search" type="text" placeholder="Search place..." class="text-black p-2 rounded w-60" />
    <button id="go" class="bg-green-500 px-3 rounded">Go</button>
  </div>

  <div id="map"></div>

  <script>
    mapboxgl.accessToken = 'pk.eyJ1Ijoic2FtdWVsbWRpbGVlcCIsImEiOiJjbWN0Mjd4a2cwMG92MmpxdXo3cDlveTlsIn0.QLTaJV0psYYAr9jpJeZjUw';

    const map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/mapbox/streets-v12',
      center: [76.2673, 9.9312],
      zoom: 13
    });

    map.addControl(new mapboxgl.NavigationControl());

    let userMarker;
    let destMarker;
    const routeLayerId = 'route';

    if (navigator.geolocation) {
      navigator.geolocation.watchPosition(pos => {
        const lng = pos.coords.longitude;
        const lat = pos.coords.latitude;

        if (!userMarker) {
          userMarker = new mapboxgl.Marker({ color: 'blue' }).setLngLat([lng, lat]).addTo(map);
        } else {
          userMarker.setLngLat([lng, lat]);
        }
      }, err => console.error(err), { enableHighAccuracy: true });
    }

    // Helpers to convert degrees <-> radians
    function toRad(deg) {
      return deg * Math.PI / 180;
    }
    function toDeg(rad) {
      return rad * 180 / Math.PI;
    }

    // Get bounding box for radius in km around center
    function getBoundingBox(center, radiusKm) {
      const lat = center[1];
      const lng = center[0];

      // Latitude: ~110.574 km per degree
      const latDelta = radiusKm / 110.574;

      // Longitude: ~111.320*cos(latitude) km per degree
      const lngDelta = radiusKm / (111.320 * Math.cos(toRad(lat)));

      return [
        lng - lngDelta, // minLng
        lat - latDelta, // minLat
        lng + lngDelta, // maxLng
        lat + latDelta  // maxLat
      ];
    }

    // Calculate haversine distance between two lng-lat points in km
    function distanceBetween(coord1, coord2) {
      const R = 6371;
      const dLat = toRad(coord2[1] - coord1[1]);
      const dLng = toRad(coord2[0] - coord1[0]);
      const lat1 = toRad(coord1[1]);
      const lat2 = toRad(coord2[1]);

      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.sin(dLng/2) * Math.sin(dLng/2) * Math.cos(lat1) * Math.cos(lat2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    // Reverse geocode coords to get place name (type: place)
    async function getPlaceName(coords) {
      const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${coords[0]},${coords[1]}.json?types=place&limit=1&access_token=${mapboxgl.accessToken}`;
      const res = await fetch(url);
      const data = await res.json();
      if (data.features && data.features.length) {
        return data.features[0].text.toLowerCase();
      }
      return '';
    }

    // Search for nearby towns/cities (places) within bounding box, exclude given names
    async function searchNearbyTowns(center, radiusKm, excludeNames=[]) {
      const bbox = getBoundingBox(center, radiusKm);
      const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/.json` +
        `?bbox=${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]}` +
        `&types=place` +
        `&limit=10` +
        `&access_token=${mapboxgl.accessToken}`;

      const res = await fetch(url);
      const data = await res.json();

      if (!data.features) return [];

      return data.features.filter(f => !excludeNames.includes(f.text.toLowerCase()));
    }

    // Search multiple POI categories around destination bbox with proximity bias
    async function searchAllCategories(center, radiusKm, proximity) {
      const bbox = getBoundingBox(center, radiusKm);
      const categories = ['market', 'mall', 'shopping', 'restaurant'];

      const promises = categories.map(cat => {
        const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(cat)}.json` +
          `?bbox=${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]}` +
          `&proximity=${proximity[0]},${proximity[1]}` +
          `&limit=5&types=poi&access_token=${mapboxgl.accessToken}`;
        return fetch(url).then(res => res.json());
      });

      const results = await Promise.all(promises);

      // Combine all features
      let allFeatures = [];
      for (const data of results) {
        if (data.features) allFeatures = allFeatures.concat(data.features);
      }

      // Filter out POIs too close to destination (<200m)
      const filtered = allFeatures.filter(f => distanceBetween(center, f.geometry.coordinates) > 0.2);

      return filtered;
    }

    let searchInProgress = false;

    document.getElementById('go').addEventListener('click', async () => {
      if (searchInProgress) return; // debounce
      searchInProgress = true;

      const place = document.getElementById('search').value.trim();
      const mode = document.getElementById('mode').value;

      if (!place) {
        alert('Type a place name!');
        searchInProgress = false;
        return;
      }

      try {
        // Geocode destination
        const geoRes = await fetch(`https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(place)}.json?access_token=${mapboxgl.accessToken}`);
        const geoData = await geoRes.json();

        if (!geoData.features.length) {
          alert('Place not found');
          searchInProgress = false;
          return;
        }

        const dest = geoData.features[0].geometry.coordinates;
        const destName = geoData.features[0].text.toLowerCase();

        // Place/move red destination marker
        if (!destMarker) {
          destMarker = new mapboxgl.Marker({ color: 'red' }).setLngLat(dest).addTo(map);
        } else {
          destMarker.setLngLat(dest);
        }

        // Start coords: user location or default Kochi
        const start = userMarker ? userMarker.getLngLat().toArray() : [76.2673, 9.9312];
        const startName = await getPlaceName(start);

        // Radius based on mode
        let radiusKm = 5;
        if (mode === 'snail') radiusKm = 50; // bigger radius for towns
        else if (mode === 'tractor') radiusKm = 15;
        else if (mode === 'looping') radiusKm = 10;

        let waypoint = null;

        if (mode === 'snail') {
          // Search for nearby towns excluding start/dest town names
          const towns = await searchNearbyTowns(start, radiusKm, [startName, destName]);

          if (towns.length) {
            // Sort by distance from start descending to get farther town for bigger detour
            towns.sort((a, b) => {
              const distA = distanceBetween(start, a.geometry.coordinates);
              const distB = distanceBetween(start, b.geometry.coordinates);
              return distB - distA; // farthest first
            });
            waypoint = towns[0].geometry.coordinates;
            console.log('Picked town waypoint:', towns[0].text, waypoint);
          } else {
            console.log('No nearby towns found within', radiusKm, 'km');
          }
        } else {
          // For other modes, fallback to POIs as before
          const pois = await searchAllCategories(dest, radiusKm, start);
          if (pois.length > 0) {
            pois.sort((a, b) => distanceBetween(start, a.geometry.coordinates) - distanceBetween(start, b.geometry.coordinates));
            waypoint = pois[0].geometry.coordinates;
            console.log('Picked POI waypoint:', waypoint);
          }
        }

        // Routing profile
        let profile = 'driving';
        if (mode === 'snail') profile = 'walking';

        // Build directions URL
        let coordsString = `${start[0]},${start[1]}`;
        if (waypoint) coordsString += `;${waypoint[0]},${waypoint[1]}`;
        coordsString += `;${dest[0]},${dest[1]}`;

        if (mode === 'snail') {
          coordsString += `;${start[0]},${start[1]}`;  // Loop back to start
        }

        const directionsUrl = `https://api.mapbox.com/directions/v5/mapbox/${profile}/${coordsString}?geometries=geojson&access_token=${mapboxgl.accessToken}`;

        const dirRes = await fetch(directionsUrl);
        const dirData = await dirRes.json();

        if (!dirData.routes || dirData.routes.length === 0) {
          alert('No route found');
          searchInProgress = false;
          return;
        }

        const route = dirData.routes[0].geometry;

        if (!route || !route.coordinates || route.coordinates.length === 0) {
          alert('Route geometry invalid or empty');
          searchInProgress = false;
          return;
        }

        // Remove old route if any
        if (map.getLayer(routeLayerId)) {
          map.removeLayer(routeLayerId);
          map.removeSource(routeLayerId);
        }

        // Paint styles per mode
        let paint = {
          'line-color': '#ff0000',
          'line-width': 4,
          'line-opacity': 1
        };
        if (mode === 'snail') {
          paint['line-color'] = '#00ff00';
          paint['line-dasharray'] = [2, 4];
          paint['line-width'] = 3;
        } else if (mode === 'tractor') {
          paint['line-color'] = '#ffa500';
          paint['line-width'] = 6;
        } else if (mode === 'looping') {
          paint['line-color'] = '#00ffff';
          paint['line-width'] = 4;
          paint['line-opacity'] = 0.7;
        }

        // Add route to map
        map.addSource(routeLayerId, {
          type: 'geojson',
          data: {
            type: 'Feature',
            geometry: route
          }
        });

        map.addLayer({
          id: routeLayerId,
          type: 'line',
          source: routeLayerId,
          layout: { 'line-join': 'round', 'line-cap': 'round' },
          paint: paint
        });

        // Fit map bounds to route
        const bounds = new mapboxgl.LngLatBounds();
        route.coordinates.forEach(c => bounds.extend(c));
        map.fitBounds(bounds, { padding: 50 });

        // Show waypoint marker and popup with name if waypoint exists
        if (waypoint) {
          // Find name for waypoint (town or POI)
          let waypointName = 'Waypoint';
          if (mode === 'snail') {
            // We searched towns
            const towns = await searchNearbyTowns(start, radiusKm, [startName, destName]);
            const town = towns.find(t => t.geometry.coordinates[0] === waypoint[0] && t.geometry.coordinates[1] === waypoint[1]);
            if (town) waypointName = town.text;
          } else {
            // For POIs
            const pois = await searchAllCategories(dest, radiusKm, start);
            const poi = pois.find(p => p.geometry.coordinates[0] === waypoint[0] && p.geometry.coordinates[1] === waypoint[1]);
            if (poi) waypointName = poi.place_name;
          }

          if (!window.waypointMarker) {
            window.waypointMarker = new mapboxgl.Marker({ color: 'yellow' }).setLngLat(waypoint).addTo(map);
          } else {
            window.waypointMarker.setLngLat(waypoint);
          }

          const popup = new mapboxgl.Popup().setText(waypointName);
          window.waypointMarker.setPopup(popup).togglePopup();

        } else if (window.waypointMarker) {
          window.waypointMarker.remove();
          window.waypointMarker = null;
        }

      } catch (error) {
        console.error('Error getting route:', error);
        alert('Error getting route: ' + error.message);
      } finally {
        searchInProgress = false;
      }
    });
  </script>
</body>
</html>
